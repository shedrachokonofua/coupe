name: blog-platform
version: "1.2.0"
description: "A comprehensive, multi-service blog platform configuration. This file is intended to be used with environment variables for secrets and environment-specific settings."

# Sentinel (API Gateway / Orchestrator) configuration.
# The OTel endpoint is configured via an environment variable to allow
# pointing to a local collector in dev and a production service in prod.
sentinel:
  port: 8080
  otel_endpoint: "${OTEL_EXPORTER_OTLP_ENDPOINT:-http://localhost:4317}"

# Identity provider configuration.
# All sensitive or environment-specific values are injected via environment variables.
identity:
  provider:
    type: "auth0"
    domain: "${AUTH0_DOMAIN}" # e.g., "mycompany.auth0.com" in prod
    client_id: "${AUTH0_CLIENT_ID}"
    client_secret: "${AUTH0_CLIENT_SECRET}"
    audience: "${AUTH0_AUDIENCE}" # e.g., "https://api.myblog.com"

# Definitions for message brokers. The connection strings are externalized.
brokers:
  # Primary message bus for commands and events
  main-bus:
    type: "nats"
    # In production, this would point to a NATS cluster: "nats://nats-1:4222,nats-2:4222"
    connection: "${NATS_URL:-nats://localhost:4222}"

# Definitions for simple, ephemeral message queues.
queues:
  email-notifications:
    broker: "main-bus"
    subject: "notifications.email.send"
  image-processing:
    broker: "main-bus"
    subject: "media.image.process"

# Definitions for durable, persistent streams (e.g., NATS JetStream).
streams:
  # Captures all events related to posts for auditing and analytics.
  post-events:
    broker: "main-bus"
    stream: "POSTS" # The name of the JetStream stream
    subjects:
      - "posts.events.created"
      - "posts.events.updated"
      - "posts.events.deleted"
    # This creates a durable consumer, so if the service restarts, it resumes from where it left off.
    consumer_name: "analytics_service_consumer"

# Centralized OpenAPI schema definitions for reusability.
# This avoids repetition and ensures consistency across the API.
openapi:
  definitions:
    Post:
      type: object
      required: [id, title, content, author_id]
      properties:
        id: { type: string, format: uuid }
        title: { type: string, minLength: 1 }
        content: { type: string, minLength: 1 }
        author_id: { type: string, format: uuid }
        published_at: { type: string, format: date-time, nullable: true }
    ApiError:
      type: object
      properties:
        error_code: { type: string }
        message: { type: string }

# --- FUNCTION DEFINITIONS ---

functions:
  # The public-facing web application (e.g., Next.js, SvelteKit served via SSR).
  web:
    image: "registry.mycompany.com/blog-web:1.2.1"
    trigger:
      type: "http"
      path: "/*"
      auth:
        type: "web"
        # Protect user-specific dashboard routes.
        protected_routes: ["/dashboard", "/dashboard/*", "/settings"]
        # Policies are logical names resolved by the Sentinel.
        # This could enforce CSRF protection or UI-specific rate limits.
        policies: ["csrf_protection", "ui_rate_limit"]
    # Scaling settings can be used to manage stateful session affinity
    # or control how often the gateway checks the function's health.
    scaling:
      session_duration: 3600 # 1 hour sessions
      health_check_interval: 15 # Check health every 15 seconds

  # The core REST API for managing blog posts.
  blog-api:
    image: "registry.mycompany.com/blog-api:1.1.0"
    trigger:
      type: "http"
      path: "/api/posts/{proxy+}" # Path matching for all sub-routes
      auth:
        type: "jwt"
        scopes: ["posts:read", "posts:write", "posts:delete"]
        # These policies could implement complex logic, e.g., checking
        # if the JWT's 'sub' claim matches the post's 'author_id'.
        policies: ["api_rate_limit", "is_post_owner"]
      # The schema here documents the API surface. A real gateway would use this for
      # request validation, routing, and generating API documentation.
      schema:
        "/api/posts":
          get:
            summary: "List all posts"
            operationId: "listPosts"
            responses:
              "200":
                description: "A list of posts."
                # The $ref would be resolved by the system using the `openapi.definitions` block.
                # This assumes your system has a mechanism to resolve these JSON Pointers.
                content: { application/json: { schema: { type: array, items: { $ref: "#/openapi/definitions/Post" }}}}
          post:
            summary: "Create a new post"
            operationId: "createPost"
            responses:
              "201": { description: "Post Created", content: { application/json: { schema: { $ref: "#/openapi/definitions/Post" }}}}
              "400": { description: "Invalid Input", content: { application/json: { schema: { $ref: "#/openapi/definitions/ApiError" }}}}

  # A background worker to send emails. Triggered by a simple queue.
  emailer:
    image: "registry.mycompany.com/emailer:1.0.0"
    trigger:
      type: "queue"
      queue: "email-notifications"
    scaling:
      # A background worker might have longer-lived connections or state.
      session_duration: 86400 # 24 hours
      health_check_interval: 60 # Check less frequently

  # A background worker that listens to the durable post events stream.
  analytics-service:
    image: "registry.mycompany.com/analytics-service:1.0.3"
    trigger:
      type: "stream"
      # This function will subscribe to the 'post-events' stream defined above.
      stream: "post-events"

  # A scheduled function for daily clean-up tasks.
  cron-job-cleaner:
    image: "registry.mycompany.com/cron-cleaner:1.0.0"
    trigger:
      type: "timer"
      # Runs at 2:00 AM every day (UTC).
      schedule: "0 2 * * *"
